var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Key } from 'webdriverio';
import { SideBarView } from '../SideBarView.js';
import { ContextMenu } from '../../index.js';
import { ElementWithContextMenu, PageDecorator, BasePage } from '../../utils.js';
import { ScmView as ScmViewLocators } from '../../../locators/1.73.0.js';
import { CMD_KEY } from '../../../constants.js';
/**
 * Page object representing the Source Control view
 *
 * @category Sidebar
 */
let ScmView = class ScmView extends SideBarView {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get SCM provider (repository) by title
     * @param title name of the repository
     * @returns promise resolving to ScmProvider object
     */
    async getProvider(title) {
        const providers = await this.getProviders();
        if (!title || providers.length === 1) {
            return providers[0];
        }
        const names = await Promise.all(providers.map(async (item) => item.getTitle()));
        const index = names.findIndex((name) => name === title);
        return index > -1 ? providers[index] : undefined;
    }
    /**
     * Get all SCM providers
     * @returns promise resolving to ScmProvider array
     */
    async getProviders() {
        const headers = await this.providerHeader$$;
        const sections = await Promise.all(headers.map(async (header) => header.$(this.locators.providerRelative)));
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return Promise.all(sections.map((section) => new ScmProvider(this.locatorMap, section, this)));
    }
    /**
     * Initialize repository in the current folder if no SCM provider is found
     * @returns true if the action was completed succesfully, false if a provider already exists
     */
    async initializeRepository() {
        const buttons = await this.initButton$$;
        if (buttons.length > 0) {
            await buttons[0].click();
            return true;
        }
        return false;
    }
};
ScmView = __decorate([
    PageDecorator(ScmViewLocators)
], ScmView);
export { ScmView };
/**
 * Page object representing a repository in the source control view
 * Maps roughly to a view section of the source control view
 *
 * @category Sidebar
 */
let ScmProvider = class ScmProvider extends BasePage {
    constructor(locators, element, view) {
        super(locators, element, view.elem);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get title of the scm provider
     */
    async getTitle() {
        return this.providerTitle$.getAttribute('innerHTML');
    }
    /**
     * Get type of the scm provider (e.g. Git)
     */
    async getType() {
        return this.providerType$.getAttribute('innerHTML');
    }
    /**
     * Find an action button for the SCM provider by title and click it. (e.g 'Commit')
     * @param title Title of the action button to click
     * @returns true if the given action could be performed, false if the button doesn't exist
     */
    async takeAction(title) {
        const header = await this.providerHeader$;
        let actions = [];
        if ((await header.getAttribute('class')).indexOf('hidden') > -1) {
            actions = (await this.view.getTitlePart().getActions()).map((action) => action.elem);
        }
        else {
            await this.elem.moveTo();
            actions = await header.$$(this.locators.action);
        }
        const names = await Promise.all(actions.map((action) => action.getAttribute('title')));
        const index = names.findIndex((item) => item === title);
        if (index > -1) {
            await actions[index].click();
            return true;
        }
        return false;
    }
    /**
     * Open a context menu using the 'More Actions...' button
     * @returns Promise resolving to a ContextMenu object
     */
    async openMoreActions() {
        const header = await this.providerHeader$;
        if ((await header.getAttribute('class')).indexOf('hidden') > -1) {
            return new MoreAction(this.locatorMap, this.view).openContextMenu();
        }
        await this.elem.moveTo();
        return new MoreAction(this.locatorMap, this).openContextMenu();
    }
    /**
     * Fill in the message field and send ctrl/cmd + enter to commit the changes
     * @param message the commit message to use
     * @returns promise resolving once the keypresses are sent
     */
    async commitChanges(message) {
        const input = await this.inputField$;
        await input.clearValue();
        await input.addValue(message);
        await browser.action('key')
            .down(CMD_KEY).down(Key.Enter)
            .up(CMD_KEY).up(Key.Enter)
            .perform();
    }
    /**
     * Get page objects for all tree items representing individual changes
     * @param staged when true, finds staged changes otherwise finds unstaged changes
     * @returns promise resolving to ScmChange object array
     */
    async getChanges(staged = false) {
        const changes = await this.getChangeCount(staged);
        const label = staged ? 'STAGED CHANGES' : 'CHANGES';
        let elements = [];
        if (changes > 0) {
            let i = -1;
            elements = await this.changeItem$$;
            for (const [index, item] of elements.entries()) {
                const name = await item.$(this.locators.changeName);
                if (await name.getText() === label) {
                    i = index + 1;
                    break;
                }
            }
            if (i < 0) {
                return [];
            }
            elements = elements.slice(i, i + changes);
        }
        return Promise.all(elements.map((element) => (new ScmChange(this.locatorMap, element, this).wait())));
    }
    /**
     * Get the number of changes for a given section
     * @param staged when true, counts the staged changes, unstaged otherwise
     * @returns promise resolving to number of changes in the given subsection
     */
    async getChangeCount(staged = false) {
        const rows = staged
            ? await this.stagedChanges$$
            : await this.changes$$;
        if (rows.length < 1) {
            return 0;
        }
        const count = await rows[0].$(this.locators.changeCount);
        return +await count.getText();
    }
};
ScmProvider = __decorate([
    PageDecorator(ScmViewLocators)
], ScmProvider);
export { ScmProvider };
/**
 * Page object representing a SCM change tree item
 *
 * @category Sidebar
 */
let ScmChange = class ScmChange extends ElementWithContextMenu {
    constructor(locators, row, provider) {
        super(locators, row, provider.elem);
        this.provider = provider;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get label as a string
     */
    async getLabel() {
        return this.changeLabel$.getText();
    }
    /**
     * Get description as a string
     */
    async getDescription() {
        const desc = await this.changeDesc$$;
        if (desc.length < 1) {
            return '';
        }
        return desc[0].getText();
    }
    /**
     * Get the status string (e.g. 'Modified')
     */
    async getStatus() {
        const res = await this.resource$;
        const status = await res.getAttribute('data-tooltip');
        if (status && status.length > 0) {
            return status;
        }
        return 'folder';
    }
    /**
     * Find if the item is expanded
     * @returns promise resolving to true if change is expanded, to false otherwise
     */
    async isExpanded() {
        const twisties = await this.expand$$;
        if (twisties.length < 1) {
            return true;
        }
        return (await twisties[0].getAttribute('class')).indexOf('collapsed') < 0;
    }
    /**
     * Expand or collapse a change item if possible, only works for folders in hierarchical view mode
     * @param expand true to expand the item, false to collapse
     * @returns promise resolving to true if the item changed state, to false otherwise
     */
    async toggleExpand(expand) {
        if (await this.isExpanded() !== expand) {
            await this.elem.click();
            return true;
        }
        return false;
    }
    /**
     * Find and click an action button available to a given change tree item
     * @param title title of the action button (e.g 'Stage Changes')
     * @returns promise resolving to true if the action was performed successfully,
     * false if the given button does not exist
     */
    async takeAction(title) {
        await this.elem.moveTo();
        const actions = await this.action$$;
        const names = await Promise.all(actions.map((action) => action.getAttribute('title')));
        const index = names.findIndex((item) => item === title);
        if (index > -1) {
            await actions[index].click();
            return true;
        }
        return false;
    }
};
ScmChange = __decorate([
    PageDecorator(ScmViewLocators)
], ScmChange);
export { ScmChange };
/**
 * More Action
 *
 * @category Sidebar
 */
let MoreAction = class MoreAction extends ElementWithContextMenu {
    constructor(locators, scm) {
        super(locators, locators.ScmView.more, scm.elem);
        this.scm = scm;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    async openContextMenu() {
        await this.elem.click();
        const shadowRootHost = await this.scm.elem.$$('shadow-root-host');
        await browser.keys('Escape');
        if (shadowRootHost.length > 0) {
            if (await this.elem.getAttribute('aria-expanded') !== 'true') {
                await this.elem.click();
            }
            const shadowRoot = $(await browser.execute('return arguments[0].shadowRoot', shadowRootHost[0]));
            return new ContextMenu(this.locatorMap, shadowRoot).wait();
        }
        return super.openContextMenu();
    }
};
MoreAction = __decorate([
    PageDecorator(ScmViewLocators)
], MoreAction);
export { MoreAction };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NtVmlldy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWdlb2JqZWN0cy9zaWRlYmFyL3NjbS9TY21WaWV3LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxHQUFHLEVBQTJCLE1BQU0sYUFBYSxDQUFBO0FBRTFELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQTtBQUMvQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUE7QUFDNUMsT0FBTyxFQUNILHNCQUFzQixFQUFvQixhQUFhLEVBQWtCLFFBQVEsRUFDcEYsTUFBTSxnQkFBZ0IsQ0FBQTtBQUN2QixPQUFPLEVBQUUsT0FBTyxJQUFJLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFBO0FBQ3hFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQTtBQUcvQzs7OztHQUlHO0FBRUgsSUFBYSxPQUFPLEdBQXBCLE1BQWEsT0FBUSxTQUFRLFdBQW1DO0lBQWhFOztRQUNJOztXQUVHO1FBQ0ksZUFBVSxHQUFHLFNBQWtCLENBQUE7SUF5QzFDLENBQUM7SUF2Q0c7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUUsS0FBYztRQUM3QixNQUFNLFNBQVMsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQTtRQUMzQyxJQUFJLENBQUMsS0FBSyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ2xDLE9BQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFBO1NBQ3RCO1FBQ0QsTUFBTSxLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQTtRQUMvRSxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMs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SCxHQUFHLENBQXVCO1FBUHJDOztXQUVHO1FBQ0ksZUFBVSxHQUFHLFNBQWtCLENBQUE7SUFPdEMsQ0FBQztJQUVELEtBQUssQ0FBQyxlQUFlO1FBQ2pCLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQTtRQUN2QixNQUFNLGNBQWMsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFBO1FBQ2pFLE1BQU0sT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUU1QixJQUFJLGNBQWMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzNCLElBQUksTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxlQUFlLENBQUMsS0FBSyxNQUFNLEVBQUU7Z0JBQzFELE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQTthQUMxQjtZQUNELE1BQU0sVUFBVSxHQUFHLENBQUMsQ0FBQyxNQUFNLE9BQU8sQ0FBQyxPQUFPLENBQUMsZ0NBQWdDLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUNoRyxPQUFPLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUE7U0FDN0Q7UUFDRCxPQUFPLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQTtJQUNsQyxDQUFDO0NBQ0osQ0FBQTtBQTNCWSxVQUFVO0lBRHRCLGFBQWEsQ0FBQyxlQUFlLENBQUM7R0FDbEIsVUFBVSxDQTJCdEI7U0EzQlksVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEtleSwgQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQgfSBmcm9tICd3ZWJkcml2ZXJpbydcblxuaW1wb3J0IHsgU2lkZUJhclZpZXcgfSBmcm9tICcuLi9TaWRlQmFyVmlldy5qcydcbmltcG9ydCB7IENvbnRleHRNZW51IH0gZnJvbSAnLi4vLi4vaW5kZXguanMnXG5pbXBvcnQge1xuICAgIEVsZW1lbnRXaXRoQ29udGV4dE1lbnUsIFZTQ29kZUxvY2F0b3JNYXAsIFBhZ2VEZWNvcmF0b3IsIElQYWdlRGVjb3JhdG9yLCBCYXNlUGFnZVxufSBmcm9tICcuLi8uLi91dGlscy5qcydcbmltcG9ydCB7IFNjbVZpZXcgYXMgU2NtVmlld0xvY2F0b3JzIH0gZnJvbSAnLi4vLi4vLi4vbG9jYXRvcnMvMS43My4wLmpzJ1xuaW1wb3J0IHsgQ01EX0tFWSB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcydcblxuZXhwb3J0IGludGVyZmFjZSBTY21WaWV3IGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIFNjbVZpZXdMb2NhdG9ycz4geyB9XG4vKipcbiAqIFBhZ2Ugb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgU291cmNlIENvbnRyb2wgdmlld1xuICpcbiAqIEBjYXRlZ29yeSBTaWRlYmFyXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFNjbVZpZXdMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBTY21WaWV3IGV4dGVuZHMgU2lkZUJhclZpZXc8dHlwZW9mIFNjbVZpZXdMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnU2NtVmlldycgYXMgY29uc3RcblxuICAgIC8qKlxuICAgICAqIEdldCBTQ00gcHJvdmlkZXIgKHJlcG9zaXRvcnkpIGJ5IHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnlcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBTY21Qcm92aWRlciBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcm92aWRlciAodGl0bGU/OiBzdHJpbmcpOiBQcm9taXNlPFNjbVByb3ZpZGVyIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXJzKClcbiAgICAgICAgaWYgKCF0aXRsZSB8fCBwcm92aWRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJzWzBdXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm92aWRlcnMubWFwKGFzeW5jIChpdGVtKSA9PiBpdGVtLmdldFRpdGxlKCkpKVxuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmZpbmRJbmRleCgobmFtZSkgPT4gbmFtZSA9PT0gdGl0bGUpXG5cbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBwcm92aWRlcnNbaW5kZXhdIDogdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBTQ00gcHJvdmlkZXJzXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gU2NtUHJvdmlkZXIgYXJyYXlcbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcm92aWRlcnMgKCk6IFByb21pc2U8U2NtUHJvdmlkZXJbXT4ge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgdGhpcy5wcm92aWRlckhlYWRlciQkXG4gICAgICAgIGNvbnN0IHNlY3Rpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwoaGVhZGVycy5tYXAoYXN5bmMgKGhlYWRlcikgPT4gaGVhZGVyLiQodGhpcy5sb2NhdG9ycy5wcm92aWRlclJlbGF0aXZlKSkpXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChzZWN0aW9ucy5tYXAoKHNlY3Rpb24pID0+IG5ldyBTY21Qcm92aWRlcih0aGlzLmxvY2F0b3JNYXAsIHNlY3Rpb24gYXMgYW55LCB0aGlzKSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSByZXBvc2l0b3J5IGluIHRoZSBjdXJyZW50IGZvbGRlciBpZiBubyBTQ00gcHJvdmlkZXIgaXMgZm91bmRcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBhY3Rpb24gd2FzIGNvbXBsZXRlZCBzdWNjZXNmdWxseSwgZmFsc2UgaWYgYSBwcm92aWRlciBhbHJlYWR5IGV4aXN0c1xuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemVSZXBvc2l0b3J5ICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgYnV0dG9ucyA9IGF3YWl0IHRoaXMuaW5pdEJ1dHRvbiQkXG4gICAgICAgIGlmIChidXR0b25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IGJ1dHRvbnNbMF0uY2xpY2soKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NtUHJvdmlkZXIgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7IH1cbi8qKlxuICogUGFnZSBvYmplY3QgcmVwcmVzZW50aW5nIGEgcmVwb3NpdG9yeSBpbiB0aGUgc291cmNlIGNvbnRyb2wgdmlld1xuICogTWFwcyByb3VnaGx5IHRvIGEgdmlldyBzZWN0aW9uIG9mIHRoZSBzb3VyY2UgY29udHJvbCB2aWV3XG4gKlxuICogQGNhdGVnb3J5IFNpZGViYXJcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoU2NtVmlld0xvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFNjbVByb3ZpZGVyIGV4dGVuZHMgQmFzZVBhZ2U8dHlwZW9mIFNjbVZpZXdMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnU2NtVmlldycgYXMgY29uc3RcbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLFxuICAgICAgICBlbGVtZW50OiBDaGFpbmFibGVQcm9taXNlRWxlbWVudDxXZWJkcml2ZXJJTy5FbGVtZW50PixcbiAgICAgICAgcHVibGljIHZpZXc6IFNjbVZpZXdcbiAgICApIHtcbiAgICAgICAgc3VwZXIobG9jYXRvcnMsIGVsZW1lbnQsIHZpZXcuZWxlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGl0bGUgb2YgdGhlIHNjbSBwcm92aWRlclxuICAgICAqL1xuICAgIGFzeW5jIGdldFRpdGxlICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlclRpdGxlJC5nZXRBdHRyaWJ1dGUoJ2lubmVySFRNTCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHR5cGUgb2YgdGhlIHNjbSBwcm92aWRlciAoZS5nLiBHaXQpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHlwZSAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXJUeXBlJC5nZXRBdHRyaWJ1dGUoJ2lubmVySFRNTCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbiBhY3Rpb24gYnV0dG9uIGZvciB0aGUgU0NNIHByb3ZpZGVyIGJ5IHRpdGxlIGFuZCBjbGljayBpdC4gKGUuZyAnQ29tbWl0JylcbiAgICAgKiBAcGFyYW0gdGl0bGUgVGl0bGUgb2YgdGhlIGFjdGlvbiBidXR0b24gdG8gY2xpY2tcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBhY3Rpb24gY291bGQgYmUgcGVyZm9ybWVkLCBmYWxzZSBpZiB0aGUgYnV0dG9uIGRvZXNuJ3QgZXhpc3RcbiAgICAgKi9cbiAgICBhc3luYyB0YWtlQWN0aW9uICh0aXRsZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGF3YWl0IHRoaXMucHJvdmlkZXJIZWFkZXIkXG4gICAgICAgIGxldCBhY3Rpb25zOiBDaGFpbmFibGVQcm9taXNlRWxlbWVudDxXZWJkcml2ZXJJTy5FbGVtZW50PltdID0gW11cbiAgICAgICAgaWYgKChhd2FpdCBoZWFkZXIuZ2V0QXR0cmlidXRlKCdjbGFzcycpKS5pbmRleE9mKCdoaWRkZW4nKSA+IC0xKSB7XG4gICAgICAgICAgICBhY3Rpb25zID0gKGF3YWl0IHRoaXMudmlldy5nZXRUaXRsZVBhcnQoKS5nZXRBY3Rpb25zKCkpLm1hcCgoYWN0aW9uKSA9PiBhY3Rpb24uZWxlbSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZWxlbS5tb3ZlVG8oKVxuICAgICAgICAgICAgYWN0aW9ucyA9IGF3YWl0IGhlYWRlci4kJCh0aGlzLmxvY2F0b3JzLmFjdGlvbikgYXMgYW55IGFzIENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+W11cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lcyA9IGF3YWl0IFByb21pc2UuYWxsKGFjdGlvbnMubWFwKChhY3Rpb24pID0+IGFjdGlvbi5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykpKVxuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbSA9PT0gdGl0bGUpXG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGF3YWl0IGFjdGlvbnNbaW5kZXhdLmNsaWNrKClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiBhIGNvbnRleHQgbWVudSB1c2luZyB0aGUgJ01vcmUgQWN0aW9ucy4uLicgYnV0dG9uXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBDb250ZXh0TWVudSBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuTW9yZUFjdGlvbnMgKCk6IFByb21pc2U8Q29udGV4dE1lbnU+IHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy5wcm92aWRlckhlYWRlciRcbiAgICAgICAgaWYgKChhd2FpdCBoZWFkZXIuZ2V0QXR0cmlidXRlKCdjbGFzcycpKS5pbmRleE9mKCdoaWRkZW4nKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vcmVBY3Rpb24odGhpcy5sb2NhdG9yTWFwLCB0aGlzLnZpZXcpLm9wZW5Db250ZXh0TWVudSgpXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5lbGVtLm1vdmVUbygpXG4gICAgICAgIHJldHVybiBuZXcgTW9yZUFjdGlvbih0aGlzLmxvY2F0b3JNYXAsIHRoaXMpLm9wZW5Db250ZXh0TWVudSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbCBpbiB0aGUgbWVzc2FnZSBmaWVsZCBhbmQgc2VuZCBjdHJsL2NtZCArIGVudGVyIHRvIGNvbW1pdCB0aGUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBtZXNzYWdlIHRoZSBjb21taXQgbWVzc2FnZSB0byB1c2VcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyBvbmNlIHRoZSBrZXlwcmVzc2VzIGFyZSBzZW50XG4gICAgICovXG4gICAgYXN5bmMgY29tbWl0Q2hhbmdlcyAobWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXdhaXQgdGhpcy5pbnB1dEZpZWxkJFxuICAgICAgICBhd2FpdCBpbnB1dC5jbGVhclZhbHVlKClcbiAgICAgICAgYXdhaXQgaW5wdXQuYWRkVmFsdWUobWVzc2FnZSlcbiAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAuZG93bihDTURfS0VZKS5kb3duKEtleS5FbnRlcilcbiAgICAgICAgICAgIC51cChDTURfS0VZKS51cChLZXkuRW50ZXIpXG4gICAgICAgICAgICAucGVyZm9ybSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHBhZ2Ugb2JqZWN0cyBmb3IgYWxsIHRyZWUgaXRlbXMgcmVwcmVzZW50aW5nIGluZGl2aWR1YWwgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBzdGFnZWQgd2hlbiB0cnVlLCBmaW5kcyBzdGFnZWQgY2hhbmdlcyBvdGhlcndpc2UgZmluZHMgdW5zdGFnZWQgY2hhbmdlc1xuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIFNjbUNoYW5nZSBvYmplY3QgYXJyYXlcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDaGFuZ2VzIChzdGFnZWQgPSBmYWxzZSk6IFByb21pc2U8U2NtQ2hhbmdlW10+IHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IHRoaXMuZ2V0Q2hhbmdlQ291bnQoc3RhZ2VkKVxuICAgICAgICBjb25zdCBsYWJlbCA9IHN0YWdlZCA/ICdTVEFHRUQgQ0hBTkdFUycgOiAnQ0hBTkdFUydcblxuICAgICAgICBsZXQgZWxlbWVudHM6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+W10gPSBbXVxuICAgICAgICBpZiAoY2hhbmdlcyA+IDApIHtcbiAgICAgICAgICAgIGxldCBpID0gLTFcbiAgICAgICAgICAgIGVsZW1lbnRzID0gYXdhaXQgdGhpcy5jaGFuZ2VJdGVtJCQgYXMgYW55XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgaXRlbV0gb2YgZWxlbWVudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGF3YWl0IGl0ZW0uJCh0aGlzLmxvY2F0b3JzLmNoYW5nZU5hbWUpXG4gICAgICAgICAgICAgICAgaWYgKGF3YWl0IG5hbWUuZ2V0VGV4dCgpID09PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBpID0gaW5kZXggKyAxXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLnNsaWNlKGksIGkgKyBjaGFuZ2VzKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIGVsZW1lbnRzLm1hcCgoZWxlbWVudCkgPT4gKFxuICAgICAgICAgICAgICAgIG5ldyBTY21DaGFuZ2UodGhpcy5sb2NhdG9yTWFwLCBlbGVtZW50LCB0aGlzKS53YWl0KClcbiAgICAgICAgICAgICkpXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBjaGFuZ2VzIGZvciBhIGdpdmVuIHNlY3Rpb25cbiAgICAgKiBAcGFyYW0gc3RhZ2VkIHdoZW4gdHJ1ZSwgY291bnRzIHRoZSBzdGFnZWQgY2hhbmdlcywgdW5zdGFnZWQgb3RoZXJ3aXNlXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gbnVtYmVyIG9mIGNoYW5nZXMgaW4gdGhlIGdpdmVuIHN1YnNlY3Rpb25cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDaGFuZ2VDb3VudCAoc3RhZ2VkID0gZmFsc2UpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgICBjb25zdCByb3dzID0gc3RhZ2VkXG4gICAgICAgICAgICA/IGF3YWl0IHRoaXMuc3RhZ2VkQ2hhbmdlcyQkXG4gICAgICAgICAgICA6IGF3YWl0IHRoaXMuY2hhbmdlcyQkXG5cbiAgICAgICAgaWYgKHJvd3MubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb3VudCA9IGF3YWl0IHJvd3NbMF0uJCh0aGlzLmxvY2F0b3JzLmNoYW5nZUNvdW50KVxuICAgICAgICByZXR1cm4gK2F3YWl0IGNvdW50LmdldFRleHQoKVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY21DaGFuZ2UgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7IH1cbi8qKlxuICogUGFnZSBvYmplY3QgcmVwcmVzZW50aW5nIGEgU0NNIGNoYW5nZSB0cmVlIGl0ZW1cbiAqXG4gKiBAY2F0ZWdvcnkgU2lkZWJhclxuICovXG5AUGFnZURlY29yYXRvcihTY21WaWV3TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgU2NtQ2hhbmdlIGV4dGVuZHMgRWxlbWVudFdpdGhDb250ZXh0TWVudTx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTY21WaWV3JyBhcyBjb25zdFxuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgcm93OiBDaGFpbmFibGVQcm9taXNlRWxlbWVudDxXZWJkcml2ZXJJTy5FbGVtZW50PixcbiAgICAgICAgcHVibGljIHByb3ZpZGVyOiBTY21Qcm92aWRlclxuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgcm93LCBwcm92aWRlci5lbGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBsYWJlbCBhcyBhIHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldExhYmVsICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VMYWJlbCQuZ2V0VGV4dCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGRlc2NyaXB0aW9uIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVzY3JpcHRpb24gKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGRlc2MgPSBhd2FpdCB0aGlzLmNoYW5nZURlc2MkJFxuICAgICAgICBpZiAoZGVzYy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzY1swXS5nZXRUZXh0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0YXR1cyBzdHJpbmcgKGUuZy4gJ01vZGlmaWVkJylcbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdGF0dXMgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucmVzb3VyY2UkXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHJlcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9vbHRpcCcpXG5cbiAgICAgICAgaWYgKHN0YXR1cyAmJiBzdGF0dXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXR1c1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZm9sZGVyJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgaWYgdGhlIGl0ZW0gaXMgZXhwYW5kZWRcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byB0cnVlIGlmIGNoYW5nZSBpcyBleHBhbmRlZCwgdG8gZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYXN5bmMgaXNFeHBhbmRlZCAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IHR3aXN0aWVzID0gYXdhaXQgdGhpcy5leHBhbmQkJFxuICAgICAgICBpZiAodHdpc3RpZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGF3YWl0IHR3aXN0aWVzWzBdLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkuaW5kZXhPZignY29sbGFwc2VkJykgPCAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kIG9yIGNvbGxhcHNlIGEgY2hhbmdlIGl0ZW0gaWYgcG9zc2libGUsIG9ubHkgd29ya3MgZm9yIGZvbGRlcnMgaW4gaGllcmFyY2hpY2FsIHZpZXcgbW9kZVxuICAgICAqIEBwYXJhbSBleHBhbmQgdHJ1ZSB0byBleHBhbmQgdGhlIGl0ZW0sIGZhbHNlIHRvIGNvbGxhcHNlXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiB0aGUgaXRlbSBjaGFuZ2VkIHN0YXRlLCB0byBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyB0b2dnbGVFeHBhbmQgKGV4cGFuZDogYm9vbGVhbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5pc0V4cGFuZGVkKCkgIT09IGV4cGFuZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbGVtLmNsaWNrKClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgY2xpY2sgYW4gYWN0aW9uIGJ1dHRvbiBhdmFpbGFibGUgdG8gYSBnaXZlbiBjaGFuZ2UgdHJlZSBpdGVtXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSBhY3Rpb24gYnV0dG9uIChlLmcgJ1N0YWdlIENoYW5nZXMnKVxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgdGhlIGFjdGlvbiB3YXMgcGVyZm9ybWVkIHN1Y2Nlc3NmdWxseSxcbiAgICAgKiBmYWxzZSBpZiB0aGUgZ2l2ZW4gYnV0dG9uIGRvZXMgbm90IGV4aXN0XG4gICAgICovXG4gICAgYXN5bmMgdGFrZUFjdGlvbiAodGl0bGU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBhd2FpdCB0aGlzLmVsZW0ubW92ZVRvKClcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IGF3YWl0IHRoaXMuYWN0aW9uJCRcbiAgICAgICAgY29uc3QgbmFtZXMgPSBhd2FpdCBQcm9taXNlLmFsbChhY3Rpb25zLm1hcCgoYWN0aW9uKSA9PiBhY3Rpb24uZ2V0QXR0cmlidXRlKCd0aXRsZScpKSlcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0gPT09IHRpdGxlKVxuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBhd2FpdCBhY3Rpb25zW2luZGV4XS5jbGljaygpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb3JlQWN0aW9uIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIFNjbVZpZXdMb2NhdG9ycz4geyB9XG4vKipcbiAqIE1vcmUgQWN0aW9uXG4gKlxuICogQGNhdGVnb3J5IFNpZGViYXJcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoU2NtVmlld0xvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIE1vcmVBY3Rpb24gZXh0ZW5kcyBFbGVtZW50V2l0aENvbnRleHRNZW51PHR5cGVvZiBTY21WaWV3TG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1NjbVZpZXcnIGFzIGNvbnN0XG5cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLFxuICAgICAgICBwdWJsaWMgc2NtOiBTY21Qcm92aWRlciB8IFNjbVZpZXdcbiAgICApIHtcbiAgICAgICAgc3VwZXIobG9jYXRvcnMsIGxvY2F0b3JzLlNjbVZpZXcubW9yZSBhcyBzdHJpbmcsIHNjbS5lbGVtKVxuICAgIH1cblxuICAgIGFzeW5jIG9wZW5Db250ZXh0TWVudSAoKTogUHJvbWlzZTxDb250ZXh0TWVudT4ge1xuICAgICAgICBhd2FpdCB0aGlzLmVsZW0uY2xpY2soKVxuICAgICAgICBjb25zdCBzaGFkb3dSb290SG9zdCA9IGF3YWl0IHRoaXMuc2NtLmVsZW0uJCQoJ3NoYWRvdy1yb290LWhvc3QnKVxuICAgICAgICBhd2FpdCBicm93c2VyLmtleXMoJ0VzY2FwZScpXG5cbiAgICAgICAgaWYgKHNoYWRvd1Jvb3RIb3N0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChhd2FpdCB0aGlzLmVsZW0uZ2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJykgIT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZWxlbS5jbGljaygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gJChhd2FpdCBicm93c2VyLmV4ZWN1dGUoJ3JldHVybiBhcmd1bWVudHNbMF0uc2hhZG93Um9vdCcsIHNoYWRvd1Jvb3RIb3N0WzBdKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29udGV4dE1lbnUodGhpcy5sb2NhdG9yTWFwLCBzaGFkb3dSb290KS53YWl0KClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIub3BlbkNvbnRleHRNZW51KClcbiAgICB9XG59XG4iXX0=