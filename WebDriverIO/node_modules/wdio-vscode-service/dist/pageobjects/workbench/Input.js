var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import clipboard from 'clipboardy';
import { Key } from 'webdriverio';
import { BasePage, PageDecorator, sleep } from '../utils.js';
import { Input as InputLocators, InputBox as InputBoxLocators, QuickOpenBox as QuickOpenBoxLocators } from '../../locators/1.73.0.js';
import { CMD_KEY } from '../../constants.js';
const HOME_KEY = process.platform === 'win32'
    ? 'a'
    : Key.Home;
/**
 * Abstract page object for input fields
 *
 * @category Workbench
 */
export class Input extends BasePage {
    /**
     * Get current text of the input field
     * @returns Promise resolving to text of the input field
     */
    async getText() {
        const input = await this.inputBox$.$(this.locators.input);
        return input.getAttribute('value');
    }
    /**
     * Set (by selecting all and typing) text in the input field
     * @param text text to set into the input field
     * @returns Promise resolving when the text is typed in
     */
    async setText(text) {
        const input = await this.inputBox$.$(this.locators.input);
        await this.clear();
        await sleep(200);
        if ((await this.getText())?.length > 0) {
            await input.click();
            await browser.action('key')
                .down(Key.End).down(Key.Shift).down(Key.Home)
                .up(Key.End).up(Key.Shift).up(Key.Home)
                .perform();
        }
        await input.addValue(text);
        // fallback to clipboard if the text gets malformed
        const currentText = await this.getText();
        if (currentText !== text) {
            await clipboard.write(text);
            if (currentText?.length) {
                const backSpaces = new Array(currentText.length).fill(Key.Backspace);
                const keyAction = browser.action('key');
                for (const key of backSpaces) {
                    keyAction.down(key).up(key);
                }
                await keyAction.perform();
            }
            await clipboard.write('');
        }
    }
    /**
     * Get the placeholder text for the input field
     * @returns Promise resolving to input placeholder
     */
    async getPlaceHolder() {
        return this.inputBox$.$(this.locators.input).getAttribute('placeholder');
    }
    /**
     * Confirm the input field by pressing Enter
     * @returns Promise resolving when the input is confirmed
     */
    async confirm() {
        await browser.action('key').down(Key.Enter).up(Key.Enter).perform();
    }
    /**
     * Cancel the input field by pressing Escape
     * @returns Promise resolving when the input is cancelled
     */
    async cancel() {
        await browser.action('key').down(Key.Escape).up(Key.Escape).perform();
    }
    /**
     * Clear the inpur field
     * @returns Promise resolving when the field is cleared
     */
    async clear() {
        const input = await this.inputBox$.$(this.locators.input);
        await input.click();
        // VS Code 1.40 breaks the default clear method, use select all + back space instead
        await browser.action('key')
            .down(Key.End).up(Key.End)
            .perform();
        await browser.action('key')
            .down(CMD_KEY).down(HOME_KEY)
            .up(CMD_KEY).up(HOME_KEY)
            .perform();
        await browser.action('key')
            .down(Key.Backspace)
            .up(Key.Backspace)
            .perform();
        if ((await input.getAttribute('value'))?.length > 0) {
            await browser.action('key')
                .down(Key.End).up(Key.End)
                .perform();
            await browser.action('key')
                .down(CMD_KEY).down(HOME_KEY)
                .up(CMD_KEY).up(HOME_KEY)
                .perform();
            await browser.action('key')
                .down(Key.Backspace).up(Key.Backspace)
                .perform();
        }
    }
    /**
     * Select (click) a quick pick option. Will scroll through the quick picks to find the item.
     * Search for the item can be done by its text, or index in the quick pick menu.
     * Note that scrolling does not affect the item's index, but it will
     * replace some items in the DOM (thus they become unreachable)
     *
     * @param indexOrText index (number) or text (string) of the item to search by
     * @returns Promise resolving when the given quick pick is selected
     */
    async selectQuickPick(indexOrText) {
        const pick = await this.findQuickPick(indexOrText);
        if (pick) {
            await pick.select();
        }
        else {
            await this.resetPosition();
        }
    }
    /**
     * Select/Deselect all quick picks using the 'select all' checkbox
     * If multiple selection is disabled on the input box, no action is performed
     *
     * @param state true to select all, false to deselect all
     * @returns Promise resolving when all quick picks have been toggled to desired state
     */
    async toggleAllQuickPicks(state) {
        const checkboxes = await this.quickPickSelectAll$$;
        if (checkboxes.length < 0) {
            return;
        }
        if (!await checkboxes[0].isSelected()) {
            await checkboxes[0].click();
        }
        if (state === false) {
            await checkboxes[0].click();
        }
    }
    /**
     * Scroll through the quick picks to find an item by the name or index
     * @param indexOrText index (number) or text (string) of the item to search by
     * @returns Promise resolvnig to QuickPickItem if found, to undefined otherwise
     */
    async findQuickPick(indexOrText) {
        const first = await this.quickPickPosition$$(1);
        if (first.length < 1) {
            await this.resetPosition();
        }
        let endReached = false;
        while (!endReached) {
            const picks = await this.getQuickPicks();
            for (const pick of picks) {
                const lastRow = await this.elem.$$(this.locatorMap.DefaultTreeSection.lastRow);
                if (lastRow.length > 0) {
                    endReached = true;
                }
                else if (await pick.elem.getAttribute('aria-posinset') === await pick.elem.getAttribute('aria-setsize')) {
                    endReached = true;
                }
                if (typeof indexOrText === 'string') {
                    const text = await pick.getLabel();
                    if (text.indexOf(indexOrText) > -1) {
                        return pick;
                    }
                }
                else if (indexOrText === pick.getIndex()) {
                    return pick;
                }
            }
            if (!endReached) {
                await browser.action('key').down(Key.PageDown).up(Key.PageDown).perform();
            }
        }
        return undefined;
    }
    /**
     * Retrieve the title of an input box if it has one
     * @returns Promise resolving to title if it exists, to undefined otherwise
     */
    async getTitle() {
        const titleBar = await this.titleBar$$;
        if (titleBar.length > 0 && await titleBar[0].isDisplayed()) {
            return (await titleBar[0].$(this.locators.title)).getText();
        }
        return undefined;
    }
    /**
     * Click on the back button if it exists
     * @returns Promise resolving to true if a button was clicked, to false otherwise
     */
    async back() {
        const titleBar = await this.titleBar$$;
        if (titleBar.length > 0 && await titleBar[0].isDisplayed()) {
            const backBtn = await titleBar[0].$$(this.locators.backButton);
            if (backBtn.length > 0 && await backBtn[0].isEnabled()) {
                await backBtn[0].click();
                return true;
            }
        }
        return false;
    }
    async resetPosition() {
        const text = await this.getText();
        await this.clear();
        await this.setText(text || '');
    }
}
/**
 * Page object representing a quick pick option in the input box
 *
 * @category Workbench
 */
let QuickPickItem = class QuickPickItem extends BasePage {
    constructor(locators, index, inputField) {
        const quickPickPositionFn = locators.Input.quickPickPosition;
        const quickPickIndexFn = locators.Input.quickPickIndex;
        const baseParam = inputField instanceof QuickOpenBox
            ? quickPickPositionFn(index)
            : quickPickIndexFn(index);
        super(locators, baseParam);
        /**
         * @private
         */
        this.locatorKey = 'Input';
        this.index = index;
        this.input = inputField;
    }
    /**
     * Get the label of the quick pick item
     */
    async getLabel() {
        return this.quickPickLabel$.getText();
    }
    /**
     * Get the description of the quick pick item
     */
    async getDescription() {
        try {
            return await this.quickPickDescription$.getText();
        }
        catch (err) {
            return undefined;
        }
    }
    /**
     * Get the index of the quick pick item
     */
    getIndex() {
        return this.index;
    }
    /**
     * Select (click) the quick pick item
     * @returns Promise resolving when the item has been clicked
     */
    async select() {
        await this.elem.click();
    }
};
QuickPickItem = __decorate([
    PageDecorator(InputLocators)
], QuickPickItem);
export { QuickPickItem };
/**
 * Plain input box variation of the input page object
 *
 * @category Workbench
 */
let InputBox = class InputBox extends Input {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = ['Input', 'InputBox'];
    }
    /**
     * Get the message below the input field
     */
    async getMessage() {
        return this.message$.getText();
    }
    async hasProgress() {
        const klass = await this.progress$.getAttribute('class');
        return klass.indexOf('done') < 0;
    }
    async getQuickPicks() {
        const picks = [];
        const elements = await this.quickList$
            .$(this.locators.rows)
            .$$(this.locators.row);
        for (const element of elements) {
            if (await element.isDisplayed()) {
                picks.push(await new QuickPickItem(this.locatorMap, parseInt(await element.getAttribute('data-index'), 10), this).wait());
            }
        }
        return picks;
    }
    /**
     * Find whether the input is showing an error
     * @returns Promise resolving to notification message
     */
    async hasError() {
        const klass = await this.inputBox$.getAttribute('class');
        return klass.indexOf('error') > -1;
    }
    /**
     * Check if the input field is masked (input type password)
     * @returns Promise resolving to notification message
     */
    async isPassword() {
        return (await this.input$.getAttribute('type')) === 'password';
    }
};
InputBox = __decorate([
    PageDecorator({ ...InputLocators, ...InputBoxLocators })
], InputBox);
export { InputBox };
/**
 * @deprecated as of VS Code 1.44.0, quick open box has been replaced with input box
 * The quick open box variation of the input
 *
 * @category Workbench
 */
let QuickOpenBox = class QuickOpenBox extends Input {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = ['Input', 'QuickOpenBox'];
    }
    async hasProgress() {
        const klass = await this.progress$
            .getAttribute('class');
        return klass.indexOf('done') < 0;
    }
    async getQuickPicks() {
        const picks = [];
        const tree = await browser.$(this.locators.quickList);
        await tree.waitForExist({ timeout: 1000 });
        const elements = await tree.$$(this.locators.row);
        for (const element of elements) {
            const index = parseInt(await element.getAttribute('aria-posinset'), 10);
            if (await element.isDisplayed()) {
                picks.push(await new QuickPickItem(this.locatorMap, index, this).wait());
            }
        }
        return picks;
    }
};
QuickOpenBox = __decorate([
    PageDecorator({ ...InputLocators, ...QuickOpenBoxLocators })
], QuickOpenBox);
export { QuickOpenBox };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5wdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvd29ya2JlbmNoL0lucHV0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sU0FBUyxNQUFNLFlBQVksQ0FBQTtBQUNsQyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sYUFBYSxDQUFBO0FBRWpDLE9BQU8sRUFDYSxRQUFRLEVBQUUsYUFBYSxFQUFvQixLQUFLLEVBQ25FLE1BQU0sYUFBYSxDQUFBO0FBQ3BCLE9BQU8sRUFDSCxLQUFLLElBQUksYUFBYSxFQUN0QixRQUFRLElBQUksZ0JBQWdCLEVBQzVCLFlBQVksSUFBSSxvQkFBb0IsRUFDdkMsTUFBTSwwQkFBMEIsQ0FBQTtBQUNqQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sb0JBQW9CLENBQUE7QUFFNUMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPO0lBQ3pDLENBQUMsQ0FBQyxHQUFHO0lBQ0wsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUE7QUFJZDs7OztHQUlHO0FBQ0gsTUFBTSxPQUFnQixLQUFNLFNBQVEsUUFBMEI7SUFDMUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLE9BQU87UUFDVCxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDekQsT0FBTyxLQUFLLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQ3RDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLE9BQU8sQ0FBRSxJQUFZO1FBQ3ZCLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUN6RCxNQUFNLElBQUksQ0FBQyxLQUFLLEVB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T0FBTyxJQUFJLFFBQVEsRUFBRTtZQUM1QixNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsTUFBTSxPQUFPLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBO1lBQ3ZFLElBQUksTUFBTSxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUU7Z0JBQzdCLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFBO2FBQzNFO1NBQ0o7UUFDRCxPQUFPLEtBQUssQ0FBQTtJQUNoQixDQUFDO0NBQ0osQ0FBQTtBQXpCWSxZQUFZO0lBRHhCLGFBQWEsQ0FBQyxFQUFFLEdBQUcsYUFBYSxFQUFFLEdBQUcsb0JBQW9CLEVBQUUsQ0FBQztHQUNoRCxZQUFZLENBeUJ4QjtTQXpCWSxZQUFZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNsaXBib2FyZCBmcm9tICdjbGlwYm9hcmR5J1xuaW1wb3J0IHsgS2V5IH0gZnJvbSAnd2ViZHJpdmVyaW8nXG5cbmltcG9ydCB7XG4gICAgSVBhZ2VEZWNvcmF0b3IsIEJhc2VQYWdlLCBQYWdlRGVjb3JhdG9yLCBWU0NvZGVMb2NhdG9yTWFwLCBzbGVlcFxufSBmcm9tICcuLi91dGlscy5qcydcbmltcG9ydCB7XG4gICAgSW5wdXQgYXMgSW5wdXRMb2NhdG9ycyxcbiAgICBJbnB1dEJveCBhcyBJbnB1dEJveExvY2F0b3JzLFxuICAgIFF1aWNrT3BlbkJveCBhcyBRdWlja09wZW5Cb3hMb2NhdG9yc1xufSBmcm9tICcuLi8uLi9sb2NhdG9ycy8xLjczLjAuanMnXG5pbXBvcnQgeyBDTURfS0VZIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJ1xuXG5jb25zdCBIT01FX0tFWSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICA/ICdhJ1xuICAgIDogS2V5LkhvbWVcblxudHlwZSBBbGxJbnB1dExvY2F0b3JzID0gdHlwZW9mIElucHV0TG9jYXRvcnMgJiB0eXBlb2YgSW5wdXRCb3hMb2NhdG9ycyAmIHR5cGVvZiBRdWlja09wZW5Cb3hMb2NhdG9yc1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dCBleHRlbmRzIElQYWdlRGVjb3JhdG9yPEFsbElucHV0TG9jYXRvcnM+IHt9XG4vKipcbiAqIEFic3RyYWN0IHBhZ2Ugb2JqZWN0IGZvciBpbnB1dCBmaWVsZHNcbiAqXG4gKiBAY2F0ZWdvcnkgV29ya2JlbmNoXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbnB1dCBleHRlbmRzIEJhc2VQYWdlPEFsbElucHV0TG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCB0ZXh0IG9mIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRleHQgb2YgdGhlIGlucHV0IGZpZWxkXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGV4dCAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBhd2FpdCB0aGlzLmlucHV0Qm94JC4kKHRoaXMubG9jYXRvcnMuaW5wdXQpXG4gICAgICAgIHJldHVybiBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgKGJ5IHNlbGVjdGluZyBhbGwgYW5kIHR5cGluZykgdGV4dCBpbiB0aGUgaW5wdXQgZmllbGRcbiAgICAgKiBAcGFyYW0gdGV4dCB0ZXh0IHRvIHNldCBpbnRvIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIHRleHQgaXMgdHlwZWQgaW5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRUZXh0ICh0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBhd2FpdCB0aGlzLmlucHV0Qm94JC4kKHRoaXMubG9jYXRvcnMuaW5wdXQpXG4gICAgICAgIGF3YWl0IHRoaXMuY2xlYXIoKVxuICAgICAgICBhd2FpdCBzbGVlcCgyMDApXG4gICAgICAgIGlmICgoYXdhaXQgdGhpcy5nZXRUZXh0KCkpPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBpbnB1dC5jbGljaygpXG4gICAgICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JylcbiAgICAgICAgICAgICAgICAuZG93bihLZXkuRW5kKS5kb3duKEtleS5TaGlmdCkuZG93bihLZXkuSG9tZSlcbiAgICAgICAgICAgICAgICAudXAoS2V5LkVuZCkudXAoS2V5LlNoaWZ0KS51cChLZXkuSG9tZSlcbiAgICAgICAgICAgICAgICAucGVyZm9ybSgpXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgaW5wdXQuYWRkVmFsdWUodGV4dClcblxuICAgICAgICAvLyBmYWxsYmFjayB0byBjbGlwYm9hcmQgaWYgdGhlIHRleHQgZ2V0cyBtYWxmb3JtZWRcbiAgICAgICAgY29uc3QgY3VycmVudFRleHQgPSBhd2FpdCB0aGlzLmdldFRleHQoKVxuICAgICAgICBpZiAoY3VycmVudFRleHQgIT09IHRleHQpIHtcbiAgICAgICAgICAgIGF3YWl0IGNsaXBib2FyZC53cml0ZSh0ZXh0KVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUZXh0Py5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWNrU3BhY2VzOiBzdHJpbmdbXSA9IG5ldyBBcnJheShjdXJyZW50VGV4dC5sZW5ndGgpLmZpbGwoS2V5LkJhY2tzcGFjZSlcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlBY3Rpb24gPSBicm93c2VyLmFjdGlvbigna2V5JylcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBiYWNrU3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleUFjdGlvbi5kb3duKGtleSkudXAoa2V5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBrZXlBY3Rpb24ucGVyZm9ybSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBjbGlwYm9hcmQud3JpdGUoJycpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBsYWNlaG9sZGVyIHRleHQgZm9yIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGlucHV0IHBsYWNlaG9sZGVyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGxhY2VIb2xkZXIgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0Qm94JC4kKHRoaXMubG9jYXRvcnMuaW5wdXQpLmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpcm0gdGhlIGlucHV0IGZpZWxkIGJ5IHByZXNzaW5nIEVudGVyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgaW5wdXQgaXMgY29uZmlybWVkXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybSAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IGJyb3dzZXIuYWN0aW9uKCdrZXknKS5kb3duKEtleS5FbnRlcikudXAoS2V5LkVudGVyKS5wZXJmb3JtKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhlIGlucHV0IGZpZWxkIGJ5IHByZXNzaW5nIEVzY2FwZVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGlucHV0IGlzIGNhbmNlbGxlZFxuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbCAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IGJyb3dzZXIuYWN0aW9uKCdrZXknKS5kb3duKEtleS5Fc2NhcGUpLnVwKEtleS5Fc2NhcGUpLnBlcmZvcm0oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBpbnB1ciBmaWVsZFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGZpZWxkIGlzIGNsZWFyZWRcbiAgICAgKi9cbiAgICBhc3luYyBjbGVhciAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXdhaXQgdGhpcy5pbnB1dEJveCQuJCh0aGlzLmxvY2F0b3JzLmlucHV0KVxuICAgICAgICBhd2FpdCBpbnB1dC5jbGljaygpXG4gICAgICAgIC8vIFZTIENvZGUgMS40MCBicmVha3MgdGhlIGRlZmF1bHQgY2xlYXIgbWV0aG9kLCB1c2Ugc2VsZWN0IGFsbCArIGJhY2sgc3BhY2UgaW5zdGVhZFxuICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JylcbiAgICAgICAgICAgIC5kb3duKEtleS5FbmQpLnVwKEtleS5FbmQpXG4gICAgICAgICAgICAucGVyZm9ybSgpXG4gICAgICAgIGF3YWl0IGJyb3dzZXIuYWN0aW9uKCdrZXknKVxuICAgICAgICAgICAgLmRvd24oQ01EX0tFWSkuZG93bihIT01FX0tFWSlcbiAgICAgICAgICAgIC51cChDTURfS0VZKS51cChIT01FX0tFWSlcbiAgICAgICAgICAgIC5wZXJmb3JtKClcbiAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAuZG93bihLZXkuQmFja3NwYWNlKVxuICAgICAgICAgICAgLnVwKEtleS5CYWNrc3BhY2UpXG4gICAgICAgICAgICAucGVyZm9ybSgpXG4gICAgICAgIGlmICgoYXdhaXQgaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpKT8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAgICAgLmRvd24oS2V5LkVuZCkudXAoS2V5LkVuZClcbiAgICAgICAgICAgICAgICAucGVyZm9ybSgpXG4gICAgICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JylcbiAgICAgICAgICAgICAgICAuZG93bihDTURfS0VZKS5kb3duKEhPTUVfS0VZKVxuICAgICAgICAgICAgICAgIC51cChDTURfS0VZKS51cChIT01FX0tFWSlcbiAgICAgICAgICAgICAgICAucGVyZm9ybSgpXG4gICAgICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JylcbiAgICAgICAgICAgICAgICAuZG93bihLZXkuQmFja3NwYWNlKS51cChLZXkuQmFja3NwYWNlKVxuICAgICAgICAgICAgICAgIC5wZXJmb3JtKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCAoY2xpY2spIGEgcXVpY2sgcGljayBvcHRpb24uIFdpbGwgc2Nyb2xsIHRocm91Z2ggdGhlIHF1aWNrIHBpY2tzIHRvIGZpbmQgdGhlIGl0ZW0uXG4gICAgICogU2VhcmNoIGZvciB0aGUgaXRlbSBjYW4gYmUgZG9uZSBieSBpdHMgdGV4dCwgb3IgaW5kZXggaW4gdGhlIHF1aWNrIHBpY2sgbWVudS5cbiAgICAgKiBOb3RlIHRoYXQgc2Nyb2xsaW5nIGRvZXMgbm90IGFmZmVjdCB0aGUgaXRlbSdzIGluZGV4LCBidXQgaXQgd2lsbFxuICAgICAqIHJlcGxhY2Ugc29tZSBpdGVtcyBpbiB0aGUgRE9NICh0aHVzIHRoZXkgYmVjb21lIHVucmVhY2hhYmxlKVxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4T3JUZXh0IGluZGV4IChudW1iZXIpIG9yIHRleHQgKHN0cmluZykgb2YgdGhlIGl0ZW0gdG8gc2VhcmNoIGJ5XG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgZ2l2ZW4gcXVpY2sgcGljayBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIHNlbGVjdFF1aWNrUGljayAoaW5kZXhPclRleHQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBwaWNrID0gYXdhaXQgdGhpcy5maW5kUXVpY2tQaWNrKGluZGV4T3JUZXh0KVxuICAgICAgICBpZiAocGljaykge1xuICAgICAgICAgICAgYXdhaXQgcGljay5zZWxlY3QoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXNldFBvc2l0aW9uKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdC9EZXNlbGVjdCBhbGwgcXVpY2sgcGlja3MgdXNpbmcgdGhlICdzZWxlY3QgYWxsJyBjaGVja2JveFxuICAgICAqIElmIG11bHRpcGxlIHNlbGVjdGlvbiBpcyBkaXNhYmxlZCBvbiB0aGUgaW5wdXQgYm94LCBubyBhY3Rpb24gaXMgcGVyZm9ybWVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGUgdHJ1ZSB0byBzZWxlY3QgYWxsLCBmYWxzZSB0byBkZXNlbGVjdCBhbGxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIGFsbCBxdWljayBwaWNrcyBoYXZlIGJlZW4gdG9nZ2xlZCB0byBkZXNpcmVkIHN0YXRlXG4gICAgICovXG4gICAgYXN5bmMgdG9nZ2xlQWxsUXVpY2tQaWNrcyAoc3RhdGU6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgY2hlY2tib3hlcyA9IGF3YWl0IHRoaXMucXVpY2tQaWNrU2VsZWN0QWxsJCRcbiAgICAgICAgaWYgKGNoZWNrYm94ZXMubGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhd2FpdCBjaGVja2JveGVzWzBdLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgYXdhaXQgY2hlY2tib3hlc1swXS5jbGljaygpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXdhaXQgY2hlY2tib3hlc1swXS5jbGljaygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdGhyb3VnaCB0aGUgcXVpY2sgcGlja3MgdG8gZmluZCBhbiBpdGVtIGJ5IHRoZSBuYW1lIG9yIGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4T3JUZXh0IGluZGV4IChudW1iZXIpIG9yIHRleHQgKHN0cmluZykgb2YgdGhlIGl0ZW0gdG8gc2VhcmNoIGJ5XG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZuaWcgdG8gUXVpY2tQaWNrSXRlbSBpZiBmb3VuZCwgdG8gdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFzeW5jIGZpbmRRdWlja1BpY2sgKGluZGV4T3JUZXh0OiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPFF1aWNrUGlja0l0ZW0gfCB1bmRlZmluZWQ+IHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSBhd2FpdCB0aGlzLnF1aWNrUGlja1Bvc2l0aW9uJCQoMSlcbiAgICAgICAgaWYgKGZpcnN0Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVzZXRQb3NpdGlvbigpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuZFJlYWNoZWQgPSBmYWxzZVxuXG4gICAgICAgIHdoaWxlICghZW5kUmVhY2hlZCkge1xuICAgICAgICAgICAgY29uc3QgcGlja3MgPSBhd2FpdCB0aGlzLmdldFF1aWNrUGlja3MoKVxuICAgICAgICAgICAgZm9yIChjb25zdCBwaWNrIG9mIHBpY2tzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFJvdyA9IGF3YWl0IHRoaXMuZWxlbS4kJCh0aGlzLmxvY2F0b3JNYXAuRGVmYXVsdFRyZWVTZWN0aW9uLmxhc3RSb3cgYXMgc3RyaW5nKVxuICAgICAgICAgICAgICAgIGlmIChsYXN0Um93Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kUmVhY2hlZCA9IHRydWVcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBwaWNrLmVsZW0uZ2V0QXR0cmlidXRlKCdhcmlhLXBvc2luc2V0JykgPT09IGF3YWl0IHBpY2suZWxlbS5nZXRBdHRyaWJ1dGUoJ2FyaWEtc2V0c2l6ZScpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZFJlYWNoZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhPclRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCBwaWNrLmdldExhYmVsKClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQuaW5kZXhPZihpbmRleE9yVGV4dCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXhPclRleHQgPT09IHBpY2suZ2V0SW5kZXgoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGlja1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZW5kUmVhY2hlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGJyb3dzZXIuYWN0aW9uKCdrZXknKS5kb3duKEtleS5QYWdlRG93bikudXAoS2V5LlBhZ2VEb3duKS5wZXJmb3JtKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHRpdGxlIG9mIGFuIGlucHV0IGJveCBpZiBpdCBoYXMgb25lXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGl0bGUgaWYgaXQgZXhpc3RzLCB0byB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGl0bGUgKCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHRpdGxlQmFyID0gYXdhaXQgdGhpcy50aXRsZUJhciQkXG4gICAgICAgIGlmICh0aXRsZUJhci5sZW5ndGggPiAwICYmIGF3YWl0IHRpdGxlQmFyWzBdLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGl0bGVCYXJbMF0uJCh0aGlzLmxvY2F0b3JzLnRpdGxlKSkuZ2V0VGV4dCgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsaWNrIG9uIHRoZSBiYWNrIGJ1dHRvbiBpZiBpdCBleGlzdHNcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0cnVlIGlmIGEgYnV0dG9uIHdhcyBjbGlja2VkLCB0byBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBiYWNrICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgdGl0bGVCYXIgPSBhd2FpdCB0aGlzLnRpdGxlQmFyJCRcbiAgICAgICAgaWYgKHRpdGxlQmFyLmxlbmd0aCA+IDAgJiYgYXdhaXQgdGl0bGVCYXJbMF0uaXNEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgYmFja0J0biA9IGF3YWl0IHRpdGxlQmFyWzBdLiQkKHRoaXMubG9jYXRvcnMuYmFja0J1dHRvbilcbiAgICAgICAgICAgIGlmIChiYWNrQnRuLmxlbmd0aCA+IDAgJiYgYXdhaXQgYmFja0J0blswXS5pc0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGJhY2tCdG5bMF0uY2xpY2soKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCB3aGV0aGVyIHRoZSBpbnB1dCBib3ggaGFzIGFuIGFjdGl2ZSBwcm9ncmVzcyBiYXJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0cnVlL2ZhbHNlXG4gICAgICovXG4gICAgYWJzdHJhY3QgaGFzUHJvZ3Jlc3MgKCk6IFByb21pc2U8Ym9vbGVhbj5cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBxdWljayBwaWNrIGl0ZW1zIGN1cnJlbnRseSBhdmFpbGFibGUgaW4gdGhlIERPTVxuICAgICAqICh2aXNpYmxlIGluIHRoZSBxdWljayBwaWNrIG1lbnUpXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXJyYXkgb2YgUXVpY2tQaWNrSXRlbSBvYmplY3RzXG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0UXVpY2tQaWNrcyAoKTogUHJvbWlzZTxRdWlja1BpY2tJdGVtW10+XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlc2V0UG9zaXRpb24gKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy5nZXRUZXh0KClcbiAgICAgICAgYXdhaXQgdGhpcy5jbGVhcigpXG4gICAgICAgIGF3YWl0IHRoaXMuc2V0VGV4dCh0ZXh0IHx8ICcnKVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWlja1BpY2tJdGVtIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIElucHV0TG9jYXRvcnM+IHt9XG4vKipcbiAqIFBhZ2Ugb2JqZWN0IHJlcHJlc2VudGluZyBhIHF1aWNrIHBpY2sgb3B0aW9uIGluIHRoZSBpbnB1dCBib3hcbiAqXG4gKiBAY2F0ZWdvcnkgV29ya2JlbmNoXG4gKi9cbkBQYWdlRGVjb3JhdG9yKElucHV0TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgUXVpY2tQaWNrSXRlbSBleHRlbmRzIEJhc2VQYWdlPHR5cGVvZiBJbnB1dExvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdJbnB1dCcgYXMgY29uc3RcbiAgICBwcml2YXRlIGluZGV4OiBudW1iZXJcbiAgICBwdWJsaWMgaW5wdXQ6IElucHV0XG5cbiAgICBjb25zdHJ1Y3RvciAobG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsIGluZGV4OiBudW1iZXIsIGlucHV0RmllbGQ6IElucHV0KSB7XG4gICAgICAgIGNvbnN0IHF1aWNrUGlja1Bvc2l0aW9uRm4gPSBsb2NhdG9ycy5JbnB1dC5xdWlja1BpY2tQb3NpdGlvbiBhcyBGdW5jdGlvblxuICAgICAgICBjb25zdCBxdWlja1BpY2tJbmRleEZuID0gbG9jYXRvcnMuSW5wdXQucXVpY2tQaWNrSW5kZXggYXMgRnVuY3Rpb25cbiAgICAgICAgY29uc3QgYmFzZVBhcmFtID0gaW5wdXRGaWVsZCBpbnN0YW5jZW9mIFF1aWNrT3BlbkJveFxuICAgICAgICAgICAgPyBxdWlja1BpY2tQb3NpdGlvbkZuKGluZGV4KSBhcyBzdHJpbmdcbiAgICAgICAgICAgIDogcXVpY2tQaWNrSW5kZXhGbihpbmRleCkgYXMgc3RyaW5nXG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCBiYXNlUGFyYW0pXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleFxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXRGaWVsZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGFiZWwgb2YgdGhlIHF1aWNrIHBpY2sgaXRlbVxuICAgICAqL1xuICAgIGFzeW5jIGdldExhYmVsICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWlja1BpY2tMYWJlbCQuZ2V0VGV4dCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgcXVpY2sgcGljayBpdGVtXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVzY3JpcHRpb24gKCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWlja1BpY2tEZXNjcmlwdGlvbiQuZ2V0VGV4dCgpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgcXVpY2sgcGljayBpdGVtXG4gICAgICovXG4gICAgZ2V0SW5kZXggKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IChjbGljaykgdGhlIHF1aWNrIHBpY2sgaXRlbVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGl0ZW0gaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqL1xuICAgIGFzeW5jIHNlbGVjdCAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuZWxlbS5jbGljaygpXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElucHV0Qm94IGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIElucHV0Qm94TG9jYXRvcnM+IHt9XG4vKipcbiAqIFBsYWluIGlucHV0IGJveCB2YXJpYXRpb24gb2YgdGhlIGlucHV0IHBhZ2Ugb2JqZWN0XG4gKlxuICogQGNhdGVnb3J5IFdvcmtiZW5jaFxuICovXG5AUGFnZURlY29yYXRvcih7IC4uLklucHV0TG9jYXRvcnMsIC4uLklucHV0Qm94TG9jYXRvcnMgfSlcbmV4cG9ydCBjbGFzcyBJbnB1dEJveCBleHRlbmRzIElucHV0IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gWydJbnB1dCcgYXMgY29uc3QsICdJbnB1dEJveCcgYXMgY29uc3RdXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1lc3NhZ2UgYmVsb3cgdGhlIGlucHV0IGZpZWxkXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TWVzc2FnZSAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZSQuZ2V0VGV4dCgpXG4gICAgfVxuXG4gICAgYXN5bmMgaGFzUHJvZ3Jlc3MgKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBrbGFzcyA9IGF3YWl0IHRoaXMucHJvZ3Jlc3MkLmdldEF0dHJpYnV0ZSgnY2xhc3MnKVxuICAgICAgICByZXR1cm4ga2xhc3MuaW5kZXhPZignZG9uZScpIDwgMFxuICAgIH1cblxuICAgIGFzeW5jIGdldFF1aWNrUGlja3MgKCk6IFByb21pc2U8UXVpY2tQaWNrSXRlbVtdPiB7XG4gICAgICAgIGNvbnN0IHBpY2tzOiBRdWlja1BpY2tJdGVtW10gPSBbXVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGF3YWl0IHRoaXMucXVpY2tMaXN0JFxuICAgICAgICAgICAgLiQodGhpcy5sb2NhdG9ycy5yb3dzKVxuICAgICAgICAgICAgLiQkKHRoaXMubG9jYXRvcnMucm93KVxuXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKGF3YWl0IGVsZW1lbnQuaXNEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgICAgIHBpY2tzLnB1c2goYXdhaXQgbmV3IFF1aWNrUGlja0l0ZW0oXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYXRvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYXdhaXQgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgKS53YWl0KCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2tzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCB3aGV0aGVyIHRoZSBpbnB1dCBpcyBzaG93aW5nIGFuIGVycm9yXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gbm90aWZpY2F0aW9uIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyBoYXNFcnJvciAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGtsYXNzID0gYXdhaXQgdGhpcy5pbnB1dEJveCQuZ2V0QXR0cmlidXRlKCdjbGFzcycpXG4gICAgICAgIHJldHVybiBrbGFzcy5pbmRleE9mKCdlcnJvcicpID4gLTFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgaW5wdXQgZmllbGQgaXMgbWFza2VkIChpbnB1dCB0eXBlIHBhc3N3b3JkKVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGlmaWNhdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgaXNQYXNzd29yZCAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5pbnB1dCQuZ2V0QXR0cmlidXRlKCd0eXBlJykpID09PSAncGFzc3dvcmQnXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1aWNrT3BlbkJveCBleHRlbmRzIElQYWdlRGVjb3JhdG9yPEFsbElucHV0TG9jYXRvcnM+IHt9XG4vKipcbiAqIEBkZXByZWNhdGVkIGFzIG9mIFZTIENvZGUgMS40NC4wLCBxdWljayBvcGVuIGJveCBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGlucHV0IGJveFxuICogVGhlIHF1aWNrIG9wZW4gYm94IHZhcmlhdGlvbiBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAY2F0ZWdvcnkgV29ya2JlbmNoXG4gKi9cbkBQYWdlRGVjb3JhdG9yKHsgLi4uSW5wdXRMb2NhdG9ycywgLi4uUXVpY2tPcGVuQm94TG9jYXRvcnMgfSlcbmV4cG9ydCBjbGFzcyBRdWlja09wZW5Cb3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9IFsnSW5wdXQnIGFzIGNvbnN0LCAnUXVpY2tPcGVuQm94JyBhcyBjb25zdF1cblxuICAgIGFzeW5jIGhhc1Byb2dyZXNzICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3Qga2xhc3MgPSBhd2FpdCB0aGlzLnByb2dyZXNzJFxuICAgICAgICAgICAgLmdldEF0dHJpYnV0ZSgnY2xhc3MnKVxuICAgICAgICByZXR1cm4ga2xhc3MuaW5kZXhPZignZG9uZScpIDwgMFxuICAgIH1cblxuICAgIGFzeW5jIGdldFF1aWNrUGlja3MgKCk6IFByb21pc2U8UXVpY2tQaWNrSXRlbVtdPiB7XG4gICAgICAgIGNvbnN0IHBpY2tzOiBRdWlja1BpY2tJdGVtW10gPSBbXVxuICAgICAgICBjb25zdCB0cmVlID0gYXdhaXQgYnJvd3Nlci4kKHRoaXMubG9jYXRvcnMucXVpY2tMaXN0KVxuICAgICAgICBhd2FpdCB0cmVlLndhaXRGb3JFeGlzdCh7IHRpbWVvdXQ6IDEwMDAgfSlcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBhd2FpdCB0cmVlLiQkKHRoaXMubG9jYXRvcnMucm93KVxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoYXdhaXQgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtcG9zaW5zZXQnKSwgMTApXG4gICAgICAgICAgICBpZiAoYXdhaXQgZWxlbWVudC5pc0Rpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICAgICAgcGlja3MucHVzaChhd2FpdCBuZXcgUXVpY2tQaWNrSXRlbSh0aGlzLmxvY2F0b3JNYXAsIGluZGV4LCB0aGlzKS53YWl0KCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2tzXG4gICAgfVxufVxuIl19