var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { TextEditor, DiffEditor, SettingsEditor } from '../index.js';
import { PageDecorator, BasePage, ElementWithContextMenu } from '../utils.js';
import { EditorView as EditorViewLocators, Editor as EditorLocatorsObj } from '../../locators/1.73.0.js';
/**
 * View handling the open editors
 *
 * @category Editor
 */
let EditorView = class EditorView extends BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'EditorView';
    }
    /**
     * Switch to an editor tab with the given title
     * @param title title of the tab
     * @param groupIndex zero based index for the editor group (0 for the left most group)
     * @returns Promise resolving to Editor object
     */
    async openEditor(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.openEditor(title);
    }
    /**
     * Close an editor tab with the given title
     * @param title title of the tab
     * @param groupIndex zero based index for the editor group (0 for the left most group)
     * @returns Promise resolving when the tab's close button is pressed
     */
    async closeEditor(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.closeEditor(title);
    }
    /**
     * Close all open editor tabs
     * @param groupIndex optional index to specify an editor group
     * @returns Promise resolving once all tabs have had their close button pressed
     */
    async closeAllEditors(groupIndex) {
        let groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            await groups[0].closeAllEditors();
            return;
        }
        while (groups.length > 0 && (await groups[0].getOpenEditorTitles()).length > 0) {
            await groups[0].closeAllEditors();
            groups = await this.getEditorGroups();
        }
    }
    /**
     * Retrieve all open editor tab titles in an array
     * @param groupIndex optional index to specify an editor group, if left empty will search all groups
     * @returns Promise resolving to array of editor titles
     */
    async getOpenEditorTitles(groupIndex) {
        const groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            return groups[groupIndex].getOpenEditorTitles();
        }
        const titles = [];
        for (const group of groups) {
            titles.push(...(await group.getOpenEditorTitles()));
        }
        return titles;
    }
    /**
     * Retrieve an editor tab from a given group by title
     * @param title title of the tab
     * @param groupIndex zero based index of the editor group, default 0 (leftmost one)
     * @returns promise resolving to EditorTab object
     */
    async getTabByTitle(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getTabByTitle(title);
    }
    /**
     * Retrieve all open editor tabs
     * @param groupIndex index of group to search for tabs, if left undefined, all groups are searched
     * @returns promise resolving to EditorTab list
     */
    async getOpenTabs(groupIndex) {
        const groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            return groups[groupIndex].getOpenTabs();
        }
        const tabs = [];
        for (const group of groups) {
            tabs.push(...(await group.getOpenTabs()));
        }
        return tabs;
    }
    /**
     * Retrieve the active editor tab
     * @returns promise resolving to EditorTab object, undefined if no tab is active
     */
    async getActiveTab() {
        const tabs = await this.getOpenTabs();
        const klasses = await Promise.all(tabs.map(async (tab) => tab.elem.getAttribute('class')));
        const index = klasses.findIndex((klass) => klass.indexOf('active') > -1);
        if (index > -1) {
            return tabs[index];
        }
        return undefined;
    }
    /**
     * Retrieve all editor groups in a list, sorted left to right
     * @returns promise resolving to an array of EditorGroup objects
     */
    async getEditorGroups() {
        const elements = await this.editorGroup$$;
        const groups = await Promise.all(elements.map(async (element) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        new EditorGroup(this.locatorMap, element, this).wait())));
        // sort the groups by x coordinates, so the leftmost is always at index 0
        for (let i = 0; i < groups.length - 1; i += 1) {
            for (let j = 0; j < groups.length - i - 1; j += 1) {
                if ((await groups[j].elem.getLocation('x')) > (await groups[j + 1].elem.getLocation('x'))) {
                    const temp = groups[j];
                    groups[j] = groups[j + 1];
                    groups[j + 1] = temp;
                }
            }
        }
        return groups;
    }
    /**
     * Retrieve an editor group with a given index (counting from left to right)
     * @param index zero based index of the editor group (leftmost group has index 0)
     * @returns promise resolving to an EditorGroup object
     */
    async getEditorGroup(index) {
        return (await this.getEditorGroups())[index];
    }
    /**
     * Get editor actions of a select editor group
     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0
     * @returns promise resolving to list of WebElement objects
     */
    async getActions(groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getActions();
    }
    /**
     * Get editor action of a select editor group, search by title
     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0
     * @returns promise resolving to WebElement object if found, undefined otherwise
     */
    async getAction(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getAction(title);
    }
};
EditorView = __decorate([
    PageDecorator(EditorViewLocators)
], EditorView);
export { EditorView };
/**
 * Page object representing an editor group
 *
 * @category Editor
 */
let EditorGroup = class EditorGroup extends BasePage {
    constructor(locators, element, view = new EditorView(locators)) {
        super(locators, element);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'EditorView';
    }
    /**
     * Switch to an editor tab with the given title
     * @param title title of the tab
     * @returns Promise resolving to Editor object
     */
    async openEditor(title) {
        const tab = await this.getTabByTitle(title);
        await tab.select();
        if (await this.settingsEditor$.isExisting()) {
            return new SettingsEditor(this.locatorMap, this).wait();
        }
        if (await this.diffEditor$.isExisting()) {
            return new DiffEditor(this.locatorMap, this.locatorMap.Editor.elem, this).wait();
        }
        return new TextEditor(this.locatorMap, this.locatorMap.Editor.elem, this).wait();
    }
    /**
     * Close an editor tab with the given title
     * @param title title of the tab
     * @returns Promise resolving when the tab's close button is pressed
     */
    async closeEditor(title) {
        const tab = await this.getTabByTitle(title);
        await tab.elem.moveTo();
        const closeButton = await tab.elem.$(this.locators.closeTab);
        await closeButton.click();
    }
    /**
     * Close all open editor tabs
     * @returns Promise resolving once all tabs have had their close button pressed
     */
    async closeAllEditors() {
        let titles = await this.getOpenEditorTitles();
        while (titles.length > 0) {
            await this.closeEditor(titles[0]);
            try {
                // check if the group still exists
                await this.elem.getTagName();
            }
            catch (err) {
                break;
            }
            titles = await this.getOpenEditorTitles();
        }
    }
    /**
     * Retrieve all open editor tab titles in an array
     * @returns Promise resolving to array of editor titles
     */
    async getOpenEditorTitles() {
        const tabs = await this.tab$$;
        const titles = [];
        for (const tab of tabs) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const title = await new EditorTab(this.locatorMap, tab, this.view).getTitle();
            titles.push(title);
        }
        return titles;
    }
    /**
     * Retrieve an editor tab by title
     * @param title title of the tab
     * @returns promise resolving to EditorTab object
     */
    async getTabByTitle(title) {
        const tabs = await this.tab$$;
        const availableLabels = new Set();
        for (const tab of tabs) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const editorTab = new EditorTab(this.locatorMap, tab, this.view);
            const label = await editorTab.getTitle();
            availableLabels.add(label);
            if (label === title) {
                return editorTab;
            }
        }
        throw new Error(`No editor with title '${title}' found, `
            + `available editor were: ${[...availableLabels].join(', ')}`);
    }
    /**
     * Retrieve all open editor tabs
     * @returns promise resolving to EditorTab list
     */
    async getOpenTabs() {
        const tabs = await this.tab$$;
        return Promise.all(tabs.map(async (tab) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        new EditorTab(this.locatorMap, tab, this.view).wait())));
    }
    /**
     * Retrieve the active editor tab
     * @returns promise resolving to EditorTab object, undefined if no tab is active
     */
    async getActiveTab() {
        const tabs = await this.getOpenTabs();
        const klasses = await Promise.all(tabs.map(async (tab) => tab.elem.getAttribute('class')));
        const index = klasses.findIndex((klass) => klass.indexOf('active') > -1);
        if (index > -1) {
            return tabs[index];
        }
        return undefined;
    }
    /**
     * Retrieve the editor action buttons as WebElements
     * @returns promise resolving to list of WebElement objects
     */
    async getActions() {
        return this.actionContainer$.$$(this.locators.actionItem);
    }
    /**
     * Find an editor action button by title
     * @param title title of the button
     * @returns promise resolving to WebElement representing the button if found, undefined otherwise
     */
    async getAction(title) {
        const actions = await this.getActions();
        for (const item of actions) {
            if (await item.getAttribute('title') === title) {
                return item;
            }
        }
        return undefined;
    }
};
EditorGroup = __decorate([
    PageDecorator(EditorViewLocators)
], EditorGroup);
export { EditorGroup };
/**
 * Page object for editor view tab
 *
 * @category Editor
 */
let EditorTab = class EditorTab extends ElementWithContextMenu {
    constructor(locators, element, view) {
        super(locators, element);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'Editor';
    }
    /**
     * Get the tab title as string
     */
    async getTitle() {
        return this.title$.getText();
    }
    /**
     * Select (click) the tab
     */
    async select() {
        await this.elem.click();
    }
};
EditorTab = __decorate([
    PageDecorator(EditorLocatorsObj)
], EditorTab);
export { EditorTab };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRpdG9yVmlldy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wYWdlb2JqZWN0cy9lZGl0b3IvRWRpdG9yVmlldy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsTUFBTSxhQUFhLENBQUE7QUFDcEUsT0FBTyxFQUNILGFBQWEsRUFBa0IsUUFBUSxFQUFFLHNCQUFzQixFQUNsRSxNQUFNLGFBQWEsQ0FBQTtBQUNwQixPQUFPLEVBQ0gsVUFBVSxJQUFJLGtCQUFrQixFQUNoQyxNQUFNLElBQUksaUJBQWlCLEVBQzlCLE1BQU0sMEJBQTBCLENBQUE7QUFHakM7Ozs7R0FJRztBQUVILElBQWEsVUFBVSxHQUF2QixNQUFhLFVBQVcsU0FBUSxRQUFtQztJQUFuRTs7UUFDSTs7V0FFRztRQUNJLGVBQVUsR0FBRyxZQUFxQixDQUFBO0lBNEo3QyxDQUFDO0lBMUpHOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLFVBQVUsQ0FBRSxLQUFhLEVBQUUsVUFBVSxHQUFHLENBQUM7UUFDM0MsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFBO1FBQ25ELE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUNsQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsV0FBVyxDQUFFLEtBQWEsRUFBRSxVQUFVLEdBQUcsQ0FBQztRQUM1QyxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUE7UUFDbkQsT0FBTyxLQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQ25DLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FBRSxVQUFtQjtRQUN0QyxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FB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b3J0IHR5cGUgeyBDaGFpbmFibGVQcm9taXNlRWxlbWVudCB9IGZyb20gJ3dlYmRyaXZlcmlvJ1xuXG5pbXBvcnQgeyBUZXh0RWRpdG9yLCBEaWZmRWRpdG9yLCBTZXR0aW5nc0VkaXRvciB9IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgICBQYWdlRGVjb3JhdG9yLCBJUGFnZURlY29yYXRvciwgQmFzZVBhZ2UsIEVsZW1lbnRXaXRoQ29udGV4dE1lbnUsIFZTQ29kZUxvY2F0b3JNYXBcbn0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQge1xuICAgIEVkaXRvclZpZXcgYXMgRWRpdG9yVmlld0xvY2F0b3JzLFxuICAgIEVkaXRvciBhcyBFZGl0b3JMb2NhdG9yc09ialxufSBmcm9tICcuLi8uLi9sb2NhdG9ycy8xLjczLjAuanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRWRpdG9yVmlldyBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBFZGl0b3JWaWV3TG9jYXRvcnM+IHt9XG4vKipcbiAqIFZpZXcgaGFuZGxpbmcgdGhlIG9wZW4gZWRpdG9yc1xuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoRWRpdG9yVmlld0xvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIEVkaXRvclZpZXcgZXh0ZW5kcyBCYXNlUGFnZTx0eXBlb2YgRWRpdG9yVmlld0xvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdFZGl0b3JWaWV3JyBhcyBjb25zdFxuXG4gICAgLyoqXG4gICAgICogU3dpdGNoIHRvIGFuIGVkaXRvciB0YWIgd2l0aCB0aGUgZ2l2ZW4gdGl0bGVcbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIHRhYlxuICAgICAqIEBwYXJhbSBncm91cEluZGV4IHplcm8gYmFzZWQgaW5kZXggZm9yIHRoZSBlZGl0b3IgZ3JvdXAgKDAgZm9yIHRoZSBsZWZ0IG1vc3QgZ3JvdXApXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIG9wZW5FZGl0b3IgKHRpdGxlOiBzdHJpbmcsIGdyb3VwSW5kZXggPSAwKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cChncm91cEluZGV4KVxuICAgICAgICByZXR1cm4gZ3JvdXAub3BlbkVkaXRvcih0aXRsZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbiBlZGl0b3IgdGFiIHdpdGggdGhlIGdpdmVuIHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSB0YWJcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCB6ZXJvIGJhc2VkIGluZGV4IGZvciB0aGUgZWRpdG9yIGdyb3VwICgwIGZvciB0aGUgbGVmdCBtb3N0IGdyb3VwKVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIHRhYidzIGNsb3NlIGJ1dHRvbiBpcyBwcmVzc2VkXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2VFZGl0b3IgKHRpdGxlOiBzdHJpbmcsIGdyb3VwSW5kZXggPSAwKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cChncm91cEluZGV4KVxuICAgICAgICByZXR1cm4gZ3JvdXAuY2xvc2VFZGl0b3IodGl0bGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgYWxsIG9wZW4gZWRpdG9yIHRhYnNcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCBvcHRpb25hbCBpbmRleCB0byBzcGVjaWZ5IGFuIGVkaXRvciBncm91cFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIG9uY2UgYWxsIHRhYnMgaGF2ZSBoYWQgdGhlaXIgY2xvc2UgYnV0dG9uIHByZXNzZWRcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZUFsbEVkaXRvcnMgKGdyb3VwSW5kZXg/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgbGV0IGdyb3VwcyA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXBzKClcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgZ3JvdXBzWzBdLmNsb3NlQWxsRWRpdG9ycygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChncm91cHMubGVuZ3RoID4gMCAmJiAoYXdhaXQgZ3JvdXBzWzBdLmdldE9wZW5FZGl0b3JUaXRsZXMoKSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgZ3JvdXBzWzBdLmNsb3NlQWxsRWRpdG9ycygpXG4gICAgICAgICAgICBncm91cHMgPSBhd2FpdCB0aGlzLmdldEVkaXRvckdyb3VwcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgb3BlbiBlZGl0b3IgdGFiIHRpdGxlcyBpbiBhbiBhcnJheVxuICAgICAqIEBwYXJhbSBncm91cEluZGV4IG9wdGlvbmFsIGluZGV4IHRvIHNwZWNpZnkgYW4gZWRpdG9yIGdyb3VwLCBpZiBsZWZ0IGVtcHR5IHdpbGwgc2VhcmNoIGFsbCBncm91cHNcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBlZGl0b3IgdGl0bGVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0T3BlbkVkaXRvclRpdGxlcyAoZ3JvdXBJbmRleD86IG51bWJlcik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cHMoKVxuICAgICAgICBpZiAoZ3JvdXBJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBzW2dyb3VwSW5kZXhdLmdldE9wZW5FZGl0b3JUaXRsZXMoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpdGxlczogc3RyaW5nW10gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGdyb3Vwcykge1xuICAgICAgICAgICAgdGl0bGVzLnB1c2goLi4uKGF3YWl0IGdyb3VwLmdldE9wZW5FZGl0b3JUaXRsZXMoKSkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpdGxlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFuIGVkaXRvciB0YWIgZnJvbSBhIGdpdmVuIGdyb3VwIGJ5IHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSB0YWJcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCB6ZXJvIGJhc2VkIGluZGV4IG9mIHRoZSBlZGl0b3IgZ3JvdXAsIGRlZmF1bHQgMCAobGVmdG1vc3Qgb25lKVxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIEVkaXRvclRhYiBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUYWJCeVRpdGxlICh0aXRsZTogc3RyaW5nLCBncm91cEluZGV4ID0gMCk6IFByb21pc2U8RWRpdG9yVGFiPiB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cChncm91cEluZGV4KVxuICAgICAgICByZXR1cm4gZ3JvdXAuZ2V0VGFiQnlUaXRsZSh0aXRsZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgb3BlbiBlZGl0b3IgdGFic1xuICAgICAqIEBwYXJhbSBncm91cEluZGV4IGluZGV4IG9mIGdyb3VwIHRvIHNlYXJjaCBmb3IgdGFicywgaWYgbGVmdCB1bmRlZmluZWQsIGFsbCBncm91cHMgYXJlIHNlYXJjaGVkXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yVGFiIGxpc3RcbiAgICAgKi9cbiAgICBhc3luYyBnZXRPcGVuVGFicyAoZ3JvdXBJbmRleD86IG51bWJlcik6IFByb21pc2U8RWRpdG9yVGFiW10+IHtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cHMoKVxuICAgICAgICBpZiAoZ3JvdXBJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBzW2dyb3VwSW5kZXhdLmdldE9wZW5UYWJzKClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJzOiBFZGl0b3JUYWJbXSA9IFtdXG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZ3JvdXBzKSB7XG4gICAgICAgICAgICB0YWJzLnB1c2goLi4uKGF3YWl0IGdyb3VwLmdldE9wZW5UYWJzKCkpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGFjdGl2ZSBlZGl0b3IgdGFiXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yVGFiIG9iamVjdCwgdW5kZWZpbmVkIGlmIG5vIHRhYiBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3RpdmVUYWIgKCk6IFByb21pc2U8RWRpdG9yVGFiIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHRhYnMgPSBhd2FpdCB0aGlzLmdldE9wZW5UYWJzKClcbiAgICAgICAgY29uc3Qga2xhc3NlcyA9IGF3YWl0IFByb21pc2UuYWxsKHRhYnMubWFwKGFzeW5jICh0YWIpID0+IHRhYi5lbGVtLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkpXG4gICAgICAgIGNvbnN0IGluZGV4ID0ga2xhc3Nlcy5maW5kSW5kZXgoKGtsYXNzKSA9PiBrbGFzcy5pbmRleE9mKCdhY3RpdmUnKSA+IC0xKVxuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFic1tpbmRleF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYWxsIGVkaXRvciBncm91cHMgaW4gYSBsaXN0LCBzb3J0ZWQgbGVmdCB0byByaWdodFxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIEVkaXRvckdyb3VwIG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRFZGl0b3JHcm91cHMgKCk6IFByb21pc2U8RWRpdG9yR3JvdXBbXT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGF3YWl0IHRoaXMuZWRpdG9yR3JvdXAkJFxuICAgICAgICBjb25zdCBncm91cHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIGVsZW1lbnRzLm1hcChhc3luYyAoZWxlbWVudCkgPT4gKFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICAgICAgbmV3IEVkaXRvckdyb3VwKHRoaXMubG9jYXRvck1hcCwgZWxlbWVudCBhcyBhbnksIHRoaXMpLndhaXQoKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIHNvcnQgdGhlIGdyb3VwcyBieSB4IGNvb3JkaW5hdGVzLCBzbyB0aGUgbGVmdG1vc3QgaXMgYWx3YXlzIGF0IGluZGV4IDBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyb3Vwcy5sZW5ndGggLSBpIC0gMTsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKChhd2FpdCBncm91cHNbal0uZWxlbS5nZXRMb2NhdGlvbigneCcpKSA+IChhd2FpdCBncm91cHNbaiArIDFdLmVsZW0uZ2V0TG9jYXRpb24oJ3gnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IGdyb3Vwc1tqXVxuICAgICAgICAgICAgICAgICAgICBncm91cHNbal0gPSBncm91cHNbaiArIDFdXG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tqICsgMV0gPSB0ZW1wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbiBlZGl0b3IgZ3JvdXAgd2l0aCBhIGdpdmVuIGluZGV4IChjb3VudGluZyBmcm9tIGxlZnQgdG8gcmlnaHQpXG4gICAgICogQHBhcmFtIGluZGV4IHplcm8gYmFzZWQgaW5kZXggb2YgdGhlIGVkaXRvciBncm91cCAobGVmdG1vc3QgZ3JvdXAgaGFzIGluZGV4IDApXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gRWRpdG9yR3JvdXAgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RWRpdG9yR3JvdXAgKGluZGV4OiBudW1iZXIpOiBQcm9taXNlPEVkaXRvckdyb3VwPiB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cHMoKSlbaW5kZXhdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGVkaXRvciBhY3Rpb25zIG9mIGEgc2VsZWN0IGVkaXRvciBncm91cFxuICAgICAqIEBwYXJhbSBncm91cEluZGV4IHplcm8gYmFzZWQgaW5kZXggb2YgdGhlIGVkaXRvciBncm91cCAobGVmdG1vc3QgZ3JvdXAgaGFzIGluZGV4IDApLCBkZWZhdWx0IDBcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBsaXN0IG9mIFdlYkVsZW1lbnQgb2JqZWN0c1xuICAgICAqL1xuICAgIGFzeW5jIGdldEFjdGlvbnMgKGdyb3VwSW5kZXggPSAwKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cChncm91cEluZGV4KVxuICAgICAgICByZXR1cm4gZ3JvdXAuZ2V0QWN0aW9ucygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGVkaXRvciBhY3Rpb24gb2YgYSBzZWxlY3QgZWRpdG9yIGdyb3VwLCBzZWFyY2ggYnkgdGl0bGVcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCB6ZXJvIGJhc2VkIGluZGV4IG9mIHRoZSBlZGl0b3IgZ3JvdXAgKGxlZnRtb3N0IGdyb3VwIGhhcyBpbmRleCAwKSwgZGVmYXVsdCAwXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gV2ViRWxlbWVudCBvYmplY3QgaWYgZm91bmQsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3Rpb24gKHRpdGxlOiBzdHJpbmcsIGdyb3VwSW5kZXggPSAwKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cChncm91cEluZGV4KVxuICAgICAgICByZXR1cm4gZ3JvdXAuZ2V0QWN0aW9uKHRpdGxlKVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFZGl0b3JHcm91cCBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBFZGl0b3JWaWV3TG9jYXRvcnM+IHt9XG4vKipcbiAqIFBhZ2Ugb2JqZWN0IHJlcHJlc2VudGluZyBhbiBlZGl0b3IgZ3JvdXBcbiAqXG4gKiBAY2F0ZWdvcnkgRWRpdG9yXG4gKi9cbkBQYWdlRGVjb3JhdG9yKEVkaXRvclZpZXdMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBFZGl0b3JHcm91cCBleHRlbmRzIEJhc2VQYWdlPHR5cGVvZiBFZGl0b3JWaWV3TG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ0VkaXRvclZpZXcnIGFzIGNvbnN0XG5cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLFxuICAgICAgICBlbGVtZW50OiBDaGFpbmFibGVQcm9taXNlRWxlbWVudDxXZWJkcml2ZXJJTy5FbGVtZW50PixcbiAgICAgICAgcHVibGljIHZpZXcgPSBuZXcgRWRpdG9yVmlldyhsb2NhdG9ycylcbiAgICApIHtcbiAgICAgICAgc3VwZXIobG9jYXRvcnMsIGVsZW1lbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dpdGNoIHRvIGFuIGVkaXRvciB0YWIgd2l0aCB0aGUgZ2l2ZW4gdGl0bGVcbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIHRhYlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIEVkaXRvciBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuRWRpdG9yICh0aXRsZTogc3RyaW5nKTogUHJvbWlzZTxTZXR0aW5nc0VkaXRvciB8IERpZmZFZGl0b3IgfCBUZXh0RWRpdG9yPiB7XG4gICAgICAgIGNvbnN0IHRhYiA9IGF3YWl0IHRoaXMuZ2V0VGFiQnlUaXRsZSh0aXRsZSlcbiAgICAgICAgYXdhaXQgdGFiLnNlbGVjdCgpXG5cbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuc2V0dGluZ3NFZGl0b3IkLmlzRXhpc3RpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXR0aW5nc0VkaXRvcihcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0b3JNYXAsXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKS53YWl0KClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmRpZmZFZGl0b3IkLmlzRXhpc3RpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaWZmRWRpdG9yKFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRvck1hcCxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0b3JNYXAuRWRpdG9yLmVsZW0gYXMgc3RyaW5nLFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICkud2FpdCgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFRleHRFZGl0b3IoXG4gICAgICAgICAgICB0aGlzLmxvY2F0b3JNYXAsXG4gICAgICAgICAgICB0aGlzLmxvY2F0b3JNYXAuRWRpdG9yLmVsZW0gYXMgc3RyaW5nLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICApLndhaXQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIGFuIGVkaXRvciB0YWIgd2l0aCB0aGUgZ2l2ZW4gdGl0bGVcbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIHRhYlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIHRhYidzIGNsb3NlIGJ1dHRvbiBpcyBwcmVzc2VkXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2VFZGl0b3IgKHRpdGxlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgdGFiID0gYXdhaXQgdGhpcy5nZXRUYWJCeVRpdGxlKHRpdGxlKVxuICAgICAgICBhd2FpdCB0YWIuZWxlbS5tb3ZlVG8oKVxuICAgICAgICBjb25zdCBjbG9zZUJ1dHRvbiA9IGF3YWl0IHRhYi5lbGVtLiQodGhpcy5sb2NhdG9ycy5jbG9zZVRhYilcbiAgICAgICAgYXdhaXQgY2xvc2VCdXR0b24uY2xpY2soKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIGFsbCBvcGVuIGVkaXRvciB0YWJzXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgb25jZSBhbGwgdGFicyBoYXZlIGhhZCB0aGVpciBjbG9zZSBidXR0b24gcHJlc3NlZFxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlQWxsRWRpdG9ycyAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGxldCB0aXRsZXMgPSBhd2FpdCB0aGlzLmdldE9wZW5FZGl0b3JUaXRsZXMoKVxuICAgICAgICB3aGlsZSAodGl0bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xvc2VFZGl0b3IodGl0bGVzWzBdKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZ3JvdXAgc3RpbGwgZXhpc3RzXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbGVtLmdldFRhZ05hbWUoKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpdGxlcyA9IGF3YWl0IHRoaXMuZ2V0T3BlbkVkaXRvclRpdGxlcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgb3BlbiBlZGl0b3IgdGFiIHRpdGxlcyBpbiBhbiBhcnJheVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIGVkaXRvciB0aXRsZXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRPcGVuRWRpdG9yVGl0bGVzICgpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IHRhYnMgPSBhd2FpdCB0aGlzLnRhYiQkXG4gICAgICAgIGNvbnN0IHRpdGxlcyA9IFtdXG4gICAgICAgIGZvciAoY29uc3QgdGFiIG9mIHRhYnMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGF3YWl0IG5ldyBFZGl0b3JUYWIodGhpcy5sb2NhdG9yTWFwLCB0YWIgYXMgYW55LCB0aGlzLnZpZXcpLmdldFRpdGxlKClcbiAgICAgICAgICAgIHRpdGxlcy5wdXNoKHRpdGxlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aXRsZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbiBlZGl0b3IgdGFiIGJ5IHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSB0YWJcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBFZGl0b3JUYWIgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGFiQnlUaXRsZSAodGl0bGU6IHN0cmluZyk6IFByb21pc2U8RWRpdG9yVGFiPiB7XG4gICAgICAgIGNvbnN0IHRhYnMgPSBhd2FpdCB0aGlzLnRhYiQkXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZUxhYmVscyA9IG5ldyBTZXQoKVxuICAgICAgICBmb3IgKGNvbnN0IHRhYiBvZiB0YWJzKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgY29uc3QgZWRpdG9yVGFiID0gbmV3IEVkaXRvclRhYih0aGlzLmxvY2F0b3JNYXAsIHRhYiBhcyBhbnksIHRoaXMudmlldylcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gYXdhaXQgZWRpdG9yVGFiLmdldFRpdGxlKClcbiAgICAgICAgICAgIGF2YWlsYWJsZUxhYmVscy5hZGQobGFiZWwpXG4gICAgICAgICAgICBpZiAobGFiZWwgPT09IHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRvclRhYlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBObyBlZGl0b3Igd2l0aCB0aXRsZSAnJHt0aXRsZX0nIGZvdW5kLCBgXG4gICAgICAgICAgICArIGBhdmFpbGFibGUgZWRpdG9yIHdlcmU6ICR7Wy4uLmF2YWlsYWJsZUxhYmVsc10uam9pbignLCAnKX1gXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgb3BlbiBlZGl0b3IgdGFic1xuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIEVkaXRvclRhYiBsaXN0XG4gICAgICovXG4gICAgYXN5bmMgZ2V0T3BlblRhYnMgKCk6IFByb21pc2U8RWRpdG9yVGFiW10+IHtcbiAgICAgICAgY29uc3QgdGFicyA9IGF3YWl0IHRoaXMudGFiJCRcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgdGFicy5tYXAoYXN5bmMgKHRhYikgPT4gKFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICAgICAgbmV3IEVkaXRvclRhYih0aGlzLmxvY2F0b3JNYXAsIHRhYiBhcyBhbnksIHRoaXMudmlldykud2FpdCgpXG4gICAgICAgICAgICApKVxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGFjdGl2ZSBlZGl0b3IgdGFiXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yVGFiIG9iamVjdCwgdW5kZWZpbmVkIGlmIG5vIHRhYiBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3RpdmVUYWIgKCk6IFByb21pc2U8RWRpdG9yVGFiIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHRhYnMgPSBhd2FpdCB0aGlzLmdldE9wZW5UYWJzKClcbiAgICAgICAgY29uc3Qga2xhc3NlcyA9IGF3YWl0IFByb21pc2UuYWxsKHRhYnMubWFwKGFzeW5jICh0YWIpID0+IHRhYi5lbGVtLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkpXG4gICAgICAgIGNvbnN0IGluZGV4ID0ga2xhc3Nlcy5maW5kSW5kZXgoKGtsYXNzKSA9PiBrbGFzcy5pbmRleE9mKCdhY3RpdmUnKSA+IC0xKVxuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFic1tpbmRleF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGVkaXRvciBhY3Rpb24gYnV0dG9ucyBhcyBXZWJFbGVtZW50c1xuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIGxpc3Qgb2YgV2ViRWxlbWVudCBvYmplY3RzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWN0aW9ucyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbkNvbnRhaW5lciQuJCQodGhpcy5sb2NhdG9ycy5hY3Rpb25JdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW4gZWRpdG9yIGFjdGlvbiBidXR0b24gYnkgdGl0bGVcbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIGJ1dHRvblxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIFdlYkVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBidXR0b24gaWYgZm91bmQsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3Rpb24gKHRpdGxlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0QWN0aW9ucygpXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgaXRlbS5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgPT09IHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVkaXRvclRhYiBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBFZGl0b3JMb2NhdG9yc09iaj4ge31cbi8qKlxuICogUGFnZSBvYmplY3QgZm9yIGVkaXRvciB2aWV3IHRhYlxuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoRWRpdG9yTG9jYXRvcnNPYmopXG5leHBvcnQgY2xhc3MgRWRpdG9yVGFiIGV4dGVuZHMgRWxlbWVudFdpdGhDb250ZXh0TWVudTx0eXBlb2YgRWRpdG9yTG9jYXRvcnNPYmo+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ0VkaXRvcicgYXMgY29uc3RcblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIGVsZW1lbnQ6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+LFxuICAgICAgICBwdWJsaWMgdmlldzogRWRpdG9yVmlld1xuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgZWxlbWVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRhYiB0aXRsZSBhcyBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUaXRsZSAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGUkLmdldFRleHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCAoY2xpY2spIHRoZSB0YWJcbiAgICAgKi9cbiAgICBhc3luYyBzZWxlY3QgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLmVsZW0uY2xpY2soKVxuICAgIH1cbn1cbiJdfQ==